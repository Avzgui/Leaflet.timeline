// Generated by CoffeeScript 1.8.0

/*
Leaflet.timeline

Show any arbitrary GeoJSON objects changing over time

(c) 2014 Jonathan Skeate
https://github.com/skeate/Leaflet.timeline
http://leafletjs.com
 */

(function() {
  L.TimelineVersion = '0.3.0';

  L.Timeline = L.GeoJSON.extend({
    includes: L.Mixin.Events,
    times: [],
    ranges: [],
    options: {
      position: "bottomleft",
      formatDate: function(date) {
        return "";
      },
      enablePlayback: true,
      steps: 1000,
      duration: 10000,
      showTicks: true
    },
    initialize: function(timedGeoJSON, options) {
      this.timedGeoJSON = timedGeoJSON;
      L.GeoJSON.prototype.initialize.call(this, void 0, options);
      L.extend(this.options, options);
      return this.process(this.timedGeoJSON);
    },
    process: function(data) {
      var earliestStart, latestEnd;
      earliestStart = Infinity;
      latestEnd = -Infinity;
      data.features.forEach((function(_this) {
        return function(feature) {
          var end, start;
          start = (new Date(feature.properties.start)).getTime();
          end = (new Date(feature.properties.end)).getTime();
          _this.ranges.push({
            start: start,
            end: end,
            geoJSON: feature
          });
          _this.times.push(start);
          _this.times.push(end);
          if (start < earliestStart) {
            earliestStart = start;
          }
          if (end > latestEnd) {
            return latestEnd = end;
          }
        };
      })(this));
      this.times = this.times.sort();
      if (!this.options.start) {
        this.options.start = earliestStart;
      }
      if (!this.options.end) {
        return this.options.end = latestEnd;
      }
    },
    setTime: function(time) {
      this.time = (new Date(time)).getTime();
      this.clearLayers();
      this.ranges.forEach((function(_this) {
        return function(range) {
          if (range.start <= _this.time && range.end >= _this.time) {
            return _this.addData(range.geoJSON);
          }
        };
      })(this));
      return this.fire('change');
    },
    onAdd: function(map) {
      L.GeoJSON.prototype.onAdd.call(this, map);
      this.timeSliderControl = L.Timeline.timeSliderControl(this);
      return this.timeSliderControl.addTo(map);
    },
    getDisplayed: function() {
      var showing;
      showing = this.ranges.filter((function(_this) {
        return function(r) {
          return r.start <= _this.time && r.end >= _this.time;
        };
      })(this));
      return showing.map(function(shown) {
        return shown.geoJSON;
      });
    }
  });

  L.Timeline.TimeSliderControl = L.Control.extend({
    initialize: function(timeline) {
      this.timeline = timeline;
      this.options.position = this.timeline.options.position;
      this.start = this.timeline.options.start;
      this.end = this.timeline.options.end;
      this.showTicks = this.timeline.options.showTicks;
      this.stepDuration = this.timeline.options.duration / this.timeline.options.steps;
      return this.stepSize = (this.end - this.start) / this.timeline.options.steps;
    },
    _buildDataList: function(container, times) {
      var datalistSelect;
      this._datalist = L.DomUtil.create('datalist', '', container);
      datalistSelect = L.DomUtil.create('select', '', this._datalist);
      times.forEach(function(time) {
        var datalistOption;
        datalistOption = L.DomUtil.create('option', '', datalistSelect);
        return datalistOption.value = time;
      });
      this._datalist.id = "timeline-datalist-" + Math.floor(Math.random() * 1000000);
      return this._timeSlider.setAttribute('list', this._datalist.id);
    },
    _makePlayPause: function(container) {
      this._playButton = L.DomUtil.create('button', 'play', container);
      this._playButton.addEventListener('click', (function(_this) {
        return function() {
          return _this._play();
        };
      })(this));
      L.DomEvent.disableClickPropagation(this._playButton);
      this._pauseButton = L.DomUtil.create('button', 'pause', container);
      this._pauseButton.addEventListener('click', (function(_this) {
        return function() {
          return _this._pause();
        };
      })(this));
      return L.DomEvent.disableClickPropagation(this._pauseButton);
    },
    _makePrevNext: function(container) {
      this._prevButton = L.DomUtil.create('button', 'prev');
      this._nextButton = L.DomUtil.create('button', 'next');
      this._playButton.parentNode.insertBefore(this._prevButton, this._playButton);
      this._playButton.parentNode.insertBefore(this._nextButton, this._pauseButton.nextSibling);
      L.DomEvent.disableClickPropagation(this._prevButton);
      L.DomEvent.disableClickPropagation(this._nextButton);
      this._prevButton.addEventListener('click', this._prev.bind(this));
      return this._nextButton.addEventListener('click', this._next.bind(this));
    },
    _makeSlider: function(container) {
      this._timeSlider = L.DomUtil.create('input', 'time-slider', container);
      this._timeSlider.type = "range";
      this._timeSlider.min = this.start;
      this._timeSlider.max = this.end;
      this._timeSlider.value = this.start;
      this._timeSlider.addEventListener('mousedown', (function(_this) {
        return function() {
          return _this.map.dragging.disable();
        };
      })(this));
      document.addEventListener('mouseup', (function(_this) {
        return function() {
          return _this.map.dragging.enable();
        };
      })(this));
      this._timeSlider.addEventListener('input', this._sliderChanged.bind(this));
      return this._timeSlider.addEventListener('change', this._sliderChanged.bind(this));
    },
    _makeOutput: function(container) {
      this._output = L.DomUtil.create('output', 'time-text', container);
      return this._output.innerHTML = this.timeline.options.formatDate(new Date(this.start));
    },
    _nearestEventTime: function(findTime, mode) {
      var lastTime, nextDiff, prevDiff, retNext, time, _i, _len, _ref;
      if (mode == null) {
        mode = 0;
      }
      retNext = false;
      lastTime = this.timeline.times[0];
      _ref = this.timeline.times.slice(1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        time = _ref[_i];
        if (retNext) {
          return time;
        }
        if (time >= findTime) {
          if (mode === -1) {
            return lastTime;
          } else if (mode === 1) {
            if (time === findTime) {
              retNext = true;
            } else {
              return time;
            }
          } else {
            prevDiff = Math.abs(findTime - lastTime);
            nextDiff = Math.abs(time - findTime);
            if (prevDiff < nextDiff) {
              return prevDiff;
            } else {
              return nextDiff;
            }
          }
        }
        lastTime = time;
      }
      return lastTime;
    },
    _prev: function() {
      var prevTime;
      this._pause();
      prevTime = this._nearestEventTime(this.timeline.time, -1);
      this._timeSlider.value = prevTime;
      return this.timeline.setTime(prevTime);
    },
    _pause: function() {
      clearTimeout(this._timer);
      return this.container.classList.remove('playing');
    },
    _play: function() {
      clearTimeout(this._timer);
      if (+this._timeSlider.value === this.end) {
        this._timeSlider.value = this.start;
      }
      this._timeSlider.stepUp(this.stepSize);
      this._sliderChanged({
        target: {
          value: this._timeSlider.value
        }
      });
      if (+this._timeSlider.value !== this.end) {
        this.container.classList.add('playing');
        return this._timer = setTimeout(this._play.bind(this, this.stepDuration));
      } else {
        return this.container.classList.remove('playing');
      }
    },
    _next: function() {
      var nextTime;
      this._pause();
      nextTime = this._nearestEventTime(this.timeline.time, 1);
      this._timeSlider.value = nextTime;
      return this.timeline.setTime(nextTime);
    },
    _sliderChanged: function(e) {
      var time;
      time = +e.target.value;
      this.timeline.setTime(time);
      return this._output.innerHTML = this.timeline.options.formatDate(new Date(time));
    },
    onAdd: function(map) {
      var buttonContainer, container;
      this.map = map;
      container = L.DomUtil.create('div', 'leaflet-control-layers ' + 'leaflet-control-layers-expanded ' + 'leaflet-timeline-controls');
      if (this.timeline.options.enablePlayback) {
        buttonContainer = L.DomUtil.create('div', 'button-container', container);
        this._makePlayPause(buttonContainer);
        this._makePrevNext(buttonContainer);
      }
      this._makeSlider(container);
      if (this.showTicks) {
        this._buildDataList(container, this.timeline.times);
      }
      this._makeOutput(container);
      this.timeline.setTime(this.start);
      return this.container = container;
    }
  });

  L.timeline = function(timedGeoJSON, options) {
    return new L.Timeline(timedGeoJSON, options);
  };

  L.Timeline.timeSliderControl = function(timeline, start, end, timelist) {
    return new L.Timeline.TimeSliderControl(timeline, start, end, timelist);
  };

}).call(this);
